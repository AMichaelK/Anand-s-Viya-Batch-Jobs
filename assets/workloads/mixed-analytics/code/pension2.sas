/******************************************************************************
 * 
 * Copyright (c) 2013 by SAS Institute Inc, Cary NC 27511  USA
 *
 * This program is part of the Mixed Analytic Workload repository of
 *   test programs used to evaluate SAS concurrent workload.    
 * NAME:  pension2.sas
 * DESCRIPTION:
 *   Compares pre- and post-erisa pensions for retirees, no worker
 *   holdings.  Same code as PENSION.SAS, but the grid is finer.
 *
 * SETUP INSTRUCTIONS:
 *   Data for this test is generated by the test.
 *
 *   OUTPUT:  none
 *
 * SYSTEM REQUIREMENTS:  It runs best if you have MEMSIZE set to 512M.
 *
 * ANTICIPATED RUNTIME:  9-20 minutes
 * TEST CHARACTERIZATION:  Memory Intensive
 *
 * SAS PRODUCTS INVOLVED:  Base SAS
 * SAS PROCEDURES INVOLVED:  MEANS, UNIVARIATE, FREQ, TABULATE
 *
 * DATA SOURCE:  SELF GENERATED
 * DATA CHARACTERIZATION:  n/a
 *
 * COMMENTS:
 * DISTRIBUTION STATUS:  External
 * CONTRIBUTED BY:  Leigh Ihnen
 *
 * HISTORY:
 *   Date       Description                       Who
 *   19JUL13    Added to Mixed Analytic Workload  Tony Brown
 *******************************************************************************/
 /**********************************************************************
 *Starting code for log review information                             
 **********************************************************************/

%macro stdout (command, debug=no);

  %local fileref fid rc;

  %let rc = %sysfunc (filename (fileref, &command, PIPE));

%if &debug=yes %then %put fileref=&fileref;

  %if &rc = 0 %then %do;

    %let fid = %sysfunc (fopen (&fileref, S));
    %if &fid ne 0 %then %do;

      %do %while(%sysfunc(fread(&fid)) = 0);

        %local line;
        %let rc = %qsysfunc(fget(&fid,line,200));

%if &debug=yes %then %put line=&line;

        &line

      %end;

      %let fid = %sysfunc (fclose (&fid));
    %end;
    %else %do;

      %put ERRROR: PIPE OPEN FAILED, %sysfunc(sysmsg());
      PIPE OPEN FAILED

    %end;

    %let rc = %sysfunc (filename (fileref));
  %end;
  %else %do;
    %put ERRROR: COMMAND PIPE SETUP FAILED, rc=&rc..;
    COMMAND PIPE SETUP FAILED
  %end;

%mend;

/**********************************************************************
 *Ending - code for log review information                            
 **********************************************************************/



/*******************************************************************************
 *                        PROGRAM SETUP
 * Use this section to alter macro variables, options, or other aspects of the
 * test.  No Edits to this Program are allowed past the Program Setup section!!
 *******************************************************************************/
%let mysysparm=%sysfunc(getoption(SYSPARM));
*%let suiteloc=%sysget(ASUITE);
%put &suiteloc;


/* End of Data Setup Section */

/* Do NOT edit below this line! */


/*******************************************************************************
 *                       END OF PROGRAM SETUP
 *******************************************************************************/

/* Do NOT edit below this line! */

options fmterr fullstimer source source2 mprint notes;

/*******************************************************************************
 *                        PASS MACRO CODE - DO NOT EDIT
 *  This section controls information printed to the log for performance analysis
 ********************************************************************************/
/* PASS: Print information to the log for performance analysis. */ 
%macro passinfo;
  data _null_;
   temp=datetime();
   temp2=lowcase(trim(left(put(temp,datetime16.))));
   call symput('datetime', trim(temp2));
 
   %if ( &SYSSCP = WIN )
   %then call symput('host', "%sysget(computername)");
   %else call symput('host', "%sysget(HOST)");
   ;
  run;

  %put PASS HEADER BEGIN;
  %put PASS HEADER os=&sysscp;
  %put PASS HEADER os2=&sysscpl;
  %put PASS HEADER host=&host;
  %put PASS HEADER ver=&sysvlong;
  %put PASS HEADER date=&datetime;
  %put PASS HEADER parm=&sysparm;

  proc options group=memory; run;
  proc options group=performance; run;
  options SASTRACE=',,,d' SASTRACELOC=saslog NOSTSUFFIX;


  libname _all_ list; run; 

  %put PASS HEADER END;
%mend passinfo;
%passinfo;
run;
 
DATA _NULL_; 
 %PUT This job started on &sysdate at &systime; 
RUN;
 
/***************************************************************************
 *                        END OF PASS MACRO CODE
 ***************************************************************************/

 /***************************************************************************
 *                         PROGRAM CODE SECTION
 ***************************************************************************/



 * COMPARES PRE- AND POST-ERISA PENSIONS FOR RETIREES, NO WORKER HOLDINGS
 * OPTIONS OBS=0;
   DATA A;

 * INITIALIZE NECESSARY CONSTANTS;

 ETA=.02; * ETA=.05; * ETA=.01;
 STEPS=5; * STEPS=2;
 MINALPHA=.001; MAXALPHA=.005; ALPHSTEP=.0002; * ALPHSTEP=.004;
 MINSIG=.02; MAXSIG=.06; SIGSTEP=.01; * SIGSTEP=.04;
 MINSIGW=500; MAXSIGW=900; SIGWSTEP=10; * SIGWSTEP=400;
 ALPHAW=3500;
 RATE=.002;
 RETIRE=240;
 DEATH=120;
 DISCOUNT=.002;
 ETARATE=ETA*RATE;
 ETARATSQ=ETARATE**2;
 PHIOFTAU=RATE*LOG(ETARATE*.00005); * + FUNCTION OF BEQUEST INTENTIONS;
 THETA1=EXP(-RETIRE*RATE);
 THETA2=EXP(-DEATH*RATE);
 THETA1M1=1-THETA1;
 THETA3=EXP(RETIRE*RATE)-1;
 THETA4=1-THETA2;

 * ESTABLISH LOOPS;

 DO ALPHA1=MINALPHA TO MAXALPHA BY ALPHSTEP;
   ALPH1=ALPHA1/ETARATE;
   DO ALPHA2=MINALPHA TO MAXALPHA BY ALPHSTEP;
     ALPH2=ALPHA2/ETARATE;
     DO SIGMA1=MINSIG TO MAXSIG BY SIGSTEP;
       SIGMA1SQ=SIGMA1**2; CV1=SIGMA1/ALPHA1;
       DO SIGMA2=MINSIG TO MAXSIG BY SIGSTEP;
         SIGMA2SQ=SIGMA2**2; CV2=SIGMA2/ALPHA2;
         SIG12MAX=(2/3)*SIGMA1*SIGMA2; SIG12INC=.5*SIG12MAX;
         DO SIGMA12=0, -SIG12INC TO -SIG12MAX BY -SIG12INC,
                        SIG12INC TO  SIG12MAX BY  SIG12INC;
           RHO12=SIGMA12/(SIGMA1*SIGMA2); SIG12SQ=SIGMA12**2;

           DET=1/(SIGMA1SQ*SIGMA2SQ-SIG12SQ);
           XER1=DET * (SIGMA2SQ*ALPH1-SIGMA12*ALPH2);
           XER2=DET * (SIGMA1SQ*ALPH2-SIGMA12*ALPH1);
           XPE1=ALPH1/SIGMA1SQ;
           XPE2=ALPH2/SIGMA2SQ;
 *         IF XP1<0 | XP2<0 THEN GO TO NEXT;

           CV1=SIGMA1/ALPHA1;
           CV2=SIGMA2/ALPHA2;
           ZAX1 = -(RHO12**2) * (((1/CV1-1/CV2)**2)/(1-RHO12)
                 + 2/(CV1*CV2))/(2*(1+RHO12));

           DO SIGMAW=MINSIGW TO MAXSIGW BY SIGWSTEP;
             SIGMAWSQ=SIGMAW**2; CVW=SIGMAW/ALPHAW;
             A = -ETARATE*ALPHAW + .5*ETARATSQ*SIGMAWSQ;
             SIG1WMAX=(2/3)*SIGMA1*SIGMAW; SIG1WINC=.5*SIG1WMAX;
             SIG2WMAX=(2/3)*SIGMA2*SIGMAW; SIG2WINC=.5*SIG2WMAX;
             DO SIGMA1W=0, -SIG1WINC TO -SIG1WMAX BY -SIG1WINC,
                            SIG1WINC TO  SIG1WMAX BY  SIG1WINC;
 *           DO SIGMA1W=SIG1WINC TO SIG1WMAX BY SIG1WINC;
               RHO1W=SIGMA1W/(SIGMA1*SIGMAW);
               DO SIGMA2W=0, -SIG2WINC TO -SIG2WMAX BY -SIG2WINC,
                              SIG2WINC TO  SIG2WMAX BY  SIG2WINC;
 *             DO SIGMA2W=SIG2WINC TO SIG2WMAX BY SIG2WINC;
                 RHO2W=SIGMA2W/(SIGMA2*SIGMAW);
                 ZAX2 = (RHO1W*RHO12-RHO2W)/CV1 + (RHO2W*RHO12-RHO1W)/CV2;
                 ZAX2 = ZAX2*RHO12/(1-RHO12**2);
                 ZAX2 = ETARATE*SIGMAW*ZAX2;

                 ARRAY EQVAR1 (I) EQVAR11-EQVAR14;
                 ARRAY EQVAR2 (I) EQVAR21-EQVAR24;
                 ARRAY EQVAR3 (I) EQVAR31-EQVAR34;
                 DO RETIRE=240 TO 60 BY -60;
 *               DO RETIRE=50 TO 20 BY -10;
 *               DO RETIRE=16 TO 4 BY -4;
 *               DO RETIRE=4 TO 1 BY -1;
                   THETA3=EXP(RETIRE*RATE)-1;
                   PHI1 = ZAX1*(THETA3+THETA4);
                   PHI2 = THETA3*ZAX2;
                   I=5-RETIRE/60;
 *                 I=5-(RETIRE-10)/10;
 *                 I=5-RETIRE/4;
 *                 I=5-RETIRE;
                   SCALE=ETARATE*THETA3*ALPHAW;
                   EQVAR1=-FUZZ(PHI1+PHI2)/SCALE;
                   END;

                 DO OVER EQVAR1;
                   IF EQVAR1<-.45 THEN EQVAR2=-.5;
                   ELSE IF EQVAR1<-.40 THEN EQVAR2=-.45;
                   ELSE IF EQVAR1<-.35 THEN EQVAR2=-.40;
                   ELSE IF EQVAR1<-.30 THEN EQVAR2=-.35;
                   ELSE IF EQVAR1<-.25 THEN EQVAR2=-.30;
                   ELSE IF EQVAR1<-.20 THEN EQVAR2=-.25;
                   ELSE IF EQVAR1<-.15 THEN EQVAR2=-.20;
                   ELSE IF EQVAR1<-.10 THEN EQVAR2=-.15;
                   ELSE IF EQVAR1<-.05 THEN EQVAR2=-.10;
                   ELSE IF EQVAR1<-.0  THEN EQVAR2=-.05;
                   ELSE IF EQVAR1=.0  THEN EQVAR2=.0;
                   ELSE IF EQVAR1<=.05 THEN EQVAR2=.05;
                   ELSE IF EQVAR1<=.10 THEN EQVAR2=.10;
                   ELSE IF EQVAR1<=.15 THEN EQVAR2=.15;
                   ELSE IF EQVAR1<=.20 THEN EQVAR2=.20;
                   ELSE IF EQVAR1<=.25 THEN EQVAR2=.25;
                   ELSE IF EQVAR1<=.30 THEN EQVAR2=.30;
                   ELSE IF EQVAR1<=.35 THEN EQVAR2=.35;
                   ELSE IF EQVAR1<=.40 THEN EQVAR2=.40;
                   ELSE IF EQVAR1<=.45 THEN EQVAR2=.45;
                   ELSE EQVAR2=.50;
                   IF EQVAR1<0 THEN EQVAR3=0;
                   ELSE IF EQVAR1=0 THEN EQVAR3=1;
                   ELSE EQVAR3=2;
                   END;
                   INDEX=EQVAR31+EQVAR32*3+EQVAR33*9+EQVAR34*27;

                 KEEP ALPHA1 ALPHA2 SIGMA1 SIGMA2 RHO12 SIGMAW RHO1W RHO2W
                      CV1 CV2 XER1 XER2 XPE1 XPE2
                      EQVAR11-EQVAR14 EQVAR21-EQVAR24 INDEX;

                 OUTPUT;

                 END; * SIGMA2W LOOP;
               END; * SIGMA1W LOOP;
             END; * SIGMAW LOOP;
 *   NEXT; END; * SIGMA12 LOOP;
         END; * SIGMA2 LOOP;
       END; * SIGMA1 LOOP;
     END; * ALPH2 LOOP;
   END; * ALPH1 LOOP;
 run;

 PROC MEANS;
 run;

 PROC UNIVARIATE; VAR EQVAR11-EQVAR14 XER1 XER2 XPE1 XPE2;
 run;

 PROC FREQ;
   TABLES ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W
   EQVAR21-EQVAR24 INDEX;
 run;

 PROC TABULATE;
   CLASS EQVAR21;
   VAR ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR11;
   TABLE
      (ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR11),
       EQVAR21*(MEAN*F=15.6);
 run;

 PROC TABULATE;
   CLASS EQVAR22;
   VAR ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR12;
   TABLE
      (ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR12),
       EQVAR22*(MEAN*F=15.6);
 run;

 PROC TABULATE;
   CLASS EQVAR23;
   VAR ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR13;
   TABLE
      (ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR13),
       EQVAR23*(MEAN*F=15.6);
 run;

 PROC TABULATE;
   CLASS EQVAR24;
   VAR ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR14;
   TABLE
      (ALPHA1 ALPHA2 SIGMA1 SIGMA2 SIGMAW RHO12 RHO1W RHO2W CV1 CV2
       XER1 XER2 XPE1 XPE2 EQVAR14),
       EQVAR24*(MEAN*F=15.6);
 run;



  /***************************************************************************
 *                      END OF PROGRAM CODE SECTION
 ***************************************************************************/

/***************************************************************************
 *                       END OF TEST
 ****************************************************************************/


